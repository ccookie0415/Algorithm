di = [-1,-1,-1,0,0,1,1,1]                                   #  한 기준점을 기준으로, 8방향으로 탐색하기 위해 di, dj 좌표 설정
dj = [-1,0,1,-1,1,-1,0,1]


T = int(input())

for tc in range(1,T+1):
    N = int(input())
    arr = [list(map(int,input().split())) for _ in range(N)]        # N줄만큼 arr 입력받았음
    lst = []

    for i in range(1,N-1):            # 우리가 기준점으로 잡아야 할 곳은, 주변에 8방향으로 모두 존재하는 부분을 기준으로 잡아야 하므로
        for j in range(1,N-1):        # 기준점으로 잡을 곳의 행,열을 1, (N-1)으로 설정한다.
            cnt = 0                   # 문제에서, 주변 8개 영역보다 모두 높아야 봉우리라고 칭할 수 있으므로, cnt라는 변수를 만들어, 기준점을 중심으로 주변에 몇 개의 낮은 구역이 있는지 찾기 위함
            for k in range(8):        # 8 방향으로 탐색하기 위해 설정
                ni = i + di[k]        # 기준점을 중심으로 탐방할 곳의 새로운 ni 좌표 설정
                nj = j + dj[k]        # 기준점을 중심으로 탐방할 곳의 새로운 nj 좌표 설정
                if arr[i][j] > arr[ni][nj]:     # 만약에 기준점의 높이가, 8 방향 중 한 좌표의 높이보다 크다면
                    cnt += 1                    # 주변의 구간보다 높다는 것이므로 cnt에 +1해준다.
            if cnt == 8:                        # 만약에 cnt가 8이라는 것은, 주변의 8 구간보다 기준점의 높이가 높다는 것이므로, 봉우리라 칭할 수 있다.
                lst.append(arr[i][j])           # 그리하여, lst라는 새로운 리스트에 봉우리의 높이를 넣어준다.


    if len(lst) == 1 or len(lst) == 0:      # 봉우리가 하나만 있거나, 없는 경우에는
        ans = -1                            # -1으로 표시
    else:                                   # 그 외의 경우에는
        ans = max(lst) - min(lst)           # 봉우리 중 가장 큰 곳의 높이에서 봉우리 중 가장 낮은 곳을 뺀다.

    print(f'#{tc} {ans}')